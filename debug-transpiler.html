<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Transpiler Debug Test</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    h1 { color: #333; }
    button { padding: 10px 20px; margin: 10px 5px; font-size: 16px; cursor: pointer; }
    #output { background: #f5f5f5; padding: 20px; border-radius: 4px; white-space: pre-wrap; font-family: monospace; font-size: 12px; max-height: 600px; overflow: auto; }
    .error { color: red; }
    .success { color: green; }
  </style>
</head>
<body>
  <h1>Transpiler Debug Test</h1>
  <p>This page tests the exact transpiler logic to debug the preview issue.</p>
  
  <button onclick="testSimpleAlert()">Test Simple Alert</button>
  <button onclick="testFormTemplate()">Test Form Template</button>
  <button onclick="testEmptyCode()">Test Empty Code</button>
  <button onclick="clearOutput()">Clear Output</button>
  
  <div id="output"></div>

  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script>
    let outputEl = document.getElementById('output');

    function clearOutput() {
      outputEl.innerHTML = '';
    }

    function log(msg, className = '') {
      const div = document.createElement('div');
      div.textContent = msg;
      if (className) div.className = className;
      outputEl.appendChild(div);
    }

    // Replicate transpiler logic exactly
    async function transpileCode(jsxCode, hooksCode) {
      log('üîß [TRANSPILER] Starting transpilation...');
      log('üîß [TRANSPILER] JSX code length: ' + jsxCode.length);
      log('üîß [TRANSPILER] Hooks code length: ' + hooksCode.length);
      log('üîß [TRANSPILER] JSX code preview (first 100 chars): ' + jsxCode.substring(0, 100));
      log('');

      try {
        // Remove imports (replicate exact logic)
        const cleanJsxCode = jsxCode
          .replace(/import\s+.*?from\s+['"]@navikt\/ds-react['"]\s*;?\n?/g, '')
          .replace(/import\s+.*?from\s+['"]@navikt\/aksel-icons['"]\s*;?\n?/g, '')
          .replace(/import\s+.*?from\s+['"]react['"]\s*;?\n?/g, '')
          .replace(/import\s+.*?from\s+['"]\.(\/hooks)?['"]\s*;?\n?/g, '');
        
        const cleanHooksCode = hooksCode
          .replace(/import\s+.*?from\s+['"]@navikt\/ds-react['"]\s*;?\n?/g, '')
          .replace(/import\s+.*?from\s+['"]@navikt\/aksel-icons['"]\s*;?\n?/g, '')
          .replace(/import\s+.*?from\s+['"]react['"]\s*;?\n?/g, '');

        const trimmedJsx = cleanJsxCode.trim();
        
        log('üîß [TRANSPILER] After cleaning - trimmed JSX length: ' + trimmedJsx.length);

        if (!trimmedJsx) {
          log('üîß [TRANSPILER] Code is empty, returning no-op component');
          return { success: true, code: 'function App() { return null; }', error: null };
        }

        // Smart wrapping
        const hasExportDefault = /export\s+default\s+(function|class|\(|const|let|var)/.test(cleanJsxCode);
        log('üîß [TRANSPILER] hasExportDefault: ' + hasExportDefault);
        
        let processedJsxCode;
        
        if (hasExportDefault) {
          log('üîß [TRANSPILER] Processing with hasExportDefault branch');
          processedJsxCode = cleanJsxCode.replace(/export\s+default\s+function\s+(\w+)/g, 'function $1');
          log('üîß [TRANSPILER] After first replace (first 100 chars): ' + processedJsxCode.substring(0, 100));
          processedJsxCode = processedJsxCode.replace(/export\s+default\s+/g, 'const App = ');
          log('üîß [TRANSPILER] After second replace (first 100 chars): ' + processedJsxCode.substring(0, 100));
        } else {
          log('üîß [TRANSPILER] Processing with designer mode (auto-wrap) branch');
          const rootElementMatches = trimmedJsx.match(/^\s*</gm);
          const hasMultipleRoots = rootElementMatches && rootElementMatches.length > 1;
          log('üîß [TRANSPILER] hasMultipleRoots: ' + hasMultipleRoots);
          
          if (hasMultipleRoots) {
            processedJsxCode = `function App() {\n  return (\n    <>\n${cleanJsxCode}\n    </>\n  );\n}`;
            log('üîß [TRANSPILER] Wrapped with fragment');
          } else {
            processedJsxCode = `function App() {\n  return (\n    ${cleanJsxCode}\n  );\n}`;
            log('üîß [TRANSPILER] Wrapped without fragment');
          }
        }

        // Process hooks
        let processedHooksCode = cleanHooksCode.replace(/export\s+(const|let|var|function|class)\s+/g, '$1 ');
        processedHooksCode = processedHooksCode.replace(/export\s*\{[^}]+\}\s*;?\n?/g, '');

        const combinedCode = `\n${processedHooksCode}\n\n${processedJsxCode}\n`;
        
        log('');
        log('üîß [TRANSPILER] Combined code:');
        log('=== START ===');
        log(combinedCode);
        log('=== END ===');
        log('');

        // Transpile
        log('üîß [TRANSPILER] Calling Babel.transform...');
        const result = Babel.transform(combinedCode, {
          presets: ['react', 'typescript'],
          filename: 'app.tsx',
        });

        if (!result || !result.code) {
          log('‚ùå [TRANSPILER] Babel returned no code', 'error');
          return { success: false, code: null, error: { message: 'No output code' } };
        }

        log('‚úÖ [TRANSPILER] Babel transform successful', 'success');
        log('üîß [TRANSPILER] Transpiled code length: ' + result.code.length);
        log('');
        log('üîß [TRANSPILER] Transpiled code (first 300 chars):');
        log(result.code.substring(0, 300));
        
        return { success: true, code: result.code, error: null };

      } catch (error) {
        log('‚ùå [TRANSPILER] Error caught: ' + error, 'error');
        log('‚ùå [TRANSPILER] Error message: ' + error.message, 'error');
        return { success: false, code: null, error: { message: error.message } };
      }
    }

    async function testSimpleAlert() {
      clearOutput();
      log('=== Test: Simple Alert ===\n', 'success');
      
      const jsxCode = '<Alert variant="info">Alert message</Alert>';
      const hooksCode = '';
      
      await transpileCode(jsxCode, hooksCode);
    }

    async function testFormTemplate() {
      clearOutput();
      log('=== Test: Form Template ===\n', 'success');
      
      const jsxCode = `export default function App() {
  return (
    <BoxNew asChild background="default" paddingBlock="space-12">
      <Page>
        <Page.Block as="main" width="text" gutters>
          <VStack gap="8">
            <Alert variant="info">Test</Alert>
          </VStack>
        </Page.Block>
      </Page>
    </BoxNew>
  )
}`;
      const hooksCode = '';
      
      await transpileCode(jsxCode, hooksCode);
    }

    async function testEmptyCode() {
      clearOutput();
      log('=== Test: Empty Code ===\n', 'success');
      
      const jsxCode = '';
      const hooksCode = '';
      
      await transpileCode(jsxCode, hooksCode);
    }
  </script>
</body>
</html>
