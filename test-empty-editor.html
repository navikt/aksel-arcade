<!DOCTYPE html>
<html>
<head>
  <title>Test Empty Editor - Transpiler Fix</title>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    body { 
      font-family: system-ui, sans-serif; 
      padding: 20px; 
      background: #1a1a1a;
      color: white;
    }
    .test { 
      margin: 20px 0; 
      padding: 15px; 
      border: 1px solid #333;
      border-radius: 8px;
      background: #2a2a2a;
    }
    .success { border-color: #0f7; }
    .error { border-color: #f33; }
    h2 { margin-top: 0; color: #0af; }
    pre { 
      background: #0a0a0a; 
      padding: 10px; 
      border-radius: 4px;
      overflow-x: auto;
    }
    .status { 
      font-weight: bold; 
      font-size: 1.2em;
    }
    .success .status { color: #0f7; }
    .error .status { color: #f33; }
  </style>
</head>
<body>
  <h1>üß™ Testing Empty Editor Transpiler Fix</h1>
  <p>This simulates what happens when the editor is completely empty (no code written yet).</p>
  
  <div id="results"></div>

  <script>
    const results = document.getElementById('results');

    function addTest(title, testFn) {
      const div = document.createElement('div');
      div.className = 'test';
      div.innerHTML = `<h2>${title}</h2><p>Running...</p>`;
      results.appendChild(div);

      try {
        const result = testFn();
        if (result.success) {
          div.className = 'test success';
          div.innerHTML = `
            <h2>${title}</h2>
            <p class="status">‚úÖ PASS</p>
            <p>${result.message}</p>
            ${result.code ? `<pre>${result.code}</pre>` : ''}
          `;
        } else {
          div.className = 'test error';
          div.innerHTML = `
            <h2>${title}</h2>
            <p class="status">‚ùå FAIL</p>
            <p>${result.message}</p>
            ${result.error ? `<pre>${result.error}</pre>` : ''}
          `;
        }
      } catch (error) {
        div.className = 'test error';
        div.innerHTML = `
          <h2>${title}</h2>
          <p class="status">‚ùå ERROR</p>
          <p>${error.message}</p>
          <pre>${error.stack}</pre>
        `;
      }
    }

    // This is the EXACT logic from transpiler.ts
    function transpileCode(jsxCode, hooksCode) {
      // Remove imports (simplified version)
      const cleanJsxCode = jsxCode
        .replace(/import\s+.*?from\s+['"]@navikt\/ds-react['"]\s*;?\n?/g, '')
        .replace(/import\s+.*?from\s+['"]@navikt\/aksel-icons['"]\s*;?\n?/g, '')
        .replace(/import\s+.*?from\s+['"]react['"]\s*;?\n?/g, '')
        .replace(/import\s+.*?from\s+['"]\.(\/hooks)?['"]\s*;?\n?/g, '');

      // Check if code is empty after cleaning
      const trimmedJsx = cleanJsxCode.trim();
      
      // THE FIX: If completely empty, return a valid no-op component
      if (!trimmedJsx) {
        return {
          success: true,
          code: 'function App() { return null; }',
          error: null
        };
      }

      // Rest of transpilation logic...
      const hasExportDefault = /export\s+default\s+(function|class|\(|const|let|var)/.test(cleanJsxCode);
      
      let processedJsxCode;
      
      if (hasExportDefault) {
        processedJsxCode = cleanJsxCode.replace(/export\s+default\s+function\s+(\w+)/g, 'function $1');
        processedJsxCode = processedJsxCode.replace(/export\s+default\s+/g, 'const App = ');
      } else {
        const rootElementMatches = trimmedJsx.match(/^\s*</gm);
        const hasMultipleRoots = rootElementMatches && rootElementMatches.length > 1;
        
        if (hasMultipleRoots) {
          processedJsxCode = `function App() {\n  return (\n    <>\n${cleanJsxCode}\n    </>\n  );\n}`;
        } else {
          processedJsxCode = `function App() {\n  return (\n    ${cleanJsxCode}\n  );\n}`;
        }
      }

      const result = Babel.transform(processedJsxCode, {
        presets: ['react', 'typescript'],
        filename: 'app.tsx',
      });

      return {
        success: true,
        code: result.code,
        error: null
      };
    }

    // Test 1: Completely empty string
    addTest('Test 1: Empty string (simulating empty editor)', () => {
      const result = transpileCode('', '');
      return {
        success: result.success && result.code.includes('return null'),
        message: result.success 
          ? 'Empty code handled correctly - returns null component'
          : 'Failed to handle empty code',
        code: result.code
      };
    });

    // Test 2: Whitespace only
    addTest('Test 2: Whitespace only', () => {
      const result = transpileCode('   \n  \n  ', '');
      return {
        success: result.success && result.code.includes('return null'),
        message: result.success 
          ? 'Whitespace-only code handled correctly'
          : 'Failed to handle whitespace-only code',
        code: result.code
      };
    });

    // Test 3: What would happen WITHOUT the fix (the old buggy behavior)
    addTest('Test 3: Old buggy behavior (empty wrapped code)', () => {
      try {
        const badCode = `function App() {\n  return (\n    \n  );\n}`;
        Babel.transform(badCode, {
          presets: ['react', 'typescript'],
          filename: 'app.tsx',
        });
        return {
          success: false,
          message: 'Should have thrown error but did not!',
        };
      } catch (error) {
        return {
          success: true,
          message: 'Confirmed: Old behavior causes the exact error user reported',
          error: error.message
        };
      }
    });

    // Test 4: Valid JSX still works
    addTest('Test 4: Valid JSX code', () => {
      const result = transpileCode('<Button>Hello</Button>', '');
      return {
        success: result.success && result.code.includes('React.createElement'),
        message: result.success 
          ? 'Valid JSX transpiles correctly'
          : 'Failed to transpile valid JSX',
        code: result.code?.substring(0, 200) + '...'
      };
    });

    // Summary
    setTimeout(() => {
      const summary = document.createElement('div');
      summary.style.cssText = 'margin-top: 40px; padding: 20px; background: #0a3; border-radius: 8px;';
      const passCount = document.querySelectorAll('.test.success').length;
      const totalCount = document.querySelectorAll('.test').length;
      summary.innerHTML = `
        <h2 style="margin-top: 0;">üìä Test Summary</h2>
        <p style="font-size: 1.3em; font-weight: bold;">
          ${passCount} / ${totalCount} tests passed
        </p>
        <p style="margin-bottom: 0;">
          ${passCount === totalCount ? '‚úÖ All tests passed! The fix is working correctly.' : '‚ùå Some tests failed. Review the results above.'}
        </p>
      `;
      results.appendChild(summary);
    }, 100);
  </script>
</body>
</html>
