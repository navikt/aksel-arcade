<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sandbox</title>
  <!-- Content Security Policy: Inline script sets appropriate CSP based on environment -->
  <script>
    // Detect if running in development (Vite dev server on port 5173) or production
    const isDev = (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') && window.location.port === '5173'
    
    // Development CSP: Allow localhost for Vite HMR
    const devCSP = "default-src 'none'; script-src 'unsafe-inline' 'unsafe-eval' http://localhost:* https://localhost:*; style-src 'unsafe-inline' http://localhost:* https://localhost:* https://cdn.nav.no; font-src https://cdn.nav.no data:; connect-src http://localhost:* https://localhost:* ws://localhost:* wss://localhost:*; img-src data: https:;"
    
    // Production CSP: Strict, only allow required CDN resources
    // Note: 'unsafe-eval' is required for user code execution (playground feature)
    // Allow 'self' for manifest.json and built assets
    const prodCSP = "default-src 'none'; script-src 'unsafe-inline' 'unsafe-eval' 'self' https://esm.sh https://cdn.nav.no https://unpkg.com; style-src 'unsafe-inline' 'self' https://cdn.nav.no; font-src https://cdn.nav.no data:; connect-src 'self' https://esm.sh https://cdn.nav.no https://unpkg.com; img-src data: https:;"
    
    // Apply appropriate CSP
    const meta = document.createElement('meta')
    meta.httpEquiv = 'Content-Security-Policy'
    meta.content = isDev ? devCSP : prodCSP
    document.head.appendChild(meta)
    
    console.log('üîí CSP applied:', isDev ? 'Development' : 'Production')
  </script>
  <!-- Aksel Darkside CSS loaded via import in sandboxAksel.ts -->
  <style>
    /* Set iframe canvas color to match preview container background */
    html {
      /* Color-scheme will be set dynamically by updateTheme function */
      /* Initial: dark (matches main app default) */
      color-scheme: dark;
      /* Use Aksel Darkside sunken background variable (adapts to theme) */
      background: var(--ax-bg-sunken);
      /* Enable scrolling when content overflows */
      overflow: auto;
      height: 100%;
    }
    
    body {
      background: transparent !important;
      width: 100%;
      min-height: 100%;
    }
    
    /* NO custom reset - Aksel Darkside provides complete reset.darkside.css via import */
    #root {
      width: 100%;
      box-sizing: border-box;
      /* maxWidth will be set dynamically via updateViewport to simulate device widths */
      /* margin: 0 auto will center the content when maxWidth < container width */
    }
    #root.light {
      color-scheme: light;
    }
    #root.dark {
      color-scheme: dark;
    }
    
    /* FIX: Theme component should fill root width */
    #root > .aksel-theme {
      background: transparent !important;
      width: 100%;
    }
    
    /* FIX: Missing Aksel textColor variants - decoration and contrast */
    /* These CSS classes are used by Heading, BodyLong, BodyShort, Label, Detail, etc. */
    /* The CSS variables exist (--ax-text-decoration, --ax-text-contrast) but the classes are missing in Aksel 7.33.1 */
    .aksel-typo--color-decoration {
      color: var(--ax-text-neutral-decoration);
    }
    
    .aksel-typo--color-decoration[data-color] {
      color: var(--ax-text-decoration);
    }
    
    .aksel-typo--color-contrast {
      color: var(--ax-text-neutral-contrast);
    }
    
    .aksel-typo--color-contrast[data-color] {
      color: var(--ax-text-contrast);
    }
    
    /* Scrollbar Styling - Match main app */
    /* Webkit browsers (Chrome, Safari, Edge) */
    ::-webkit-scrollbar {
      width: 8px; /* thin scrollbar */
      height: 8px; /* thin scrollbar */
      background: transparent;
    }

    ::-webkit-scrollbar-track {
      background: transparent;
    }

    ::-webkit-scrollbar-thumb {
      background: var(--ax-text-neutral-decoration);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: var(--ax-text-neutral-decoration);
      opacity: 0.8;
    }

    /* Firefox */
    * {
      scrollbar-color: var(--ax-text-neutral-decoration) transparent;
      scrollbar-width: thin;
    }
    
    /* CRITICAL FIX: Force Alert text to use correct color in light mode */
    /* Aksel Alert component should handle this, but explicitly ensure it */
    html.light .aksel-alert,
    html.light .aksel-alert .aksel-body-long,
    html.light .aksel-alert .aksel-alert__wrapper {
      color: var(--ax-text-neutral) !important;
    }
    
    html.dark .aksel-alert,
    html.dark .aksel-alert .aksel-body-long,
    html.dark .aksel-alert .aksel-alert__wrapper {
      color: var(--ax-text-neutral) !important;
    }
  </style>
</head>
<body>
  <!-- Apply aksel-theme and light classes for Darkside styling to both html and root -->
  <!-- data-color activates Darkside color system -->
  <script>
    // Set initial theme classes on html element for background (matches main app default: dark)
    document.documentElement.className = 'aksel-theme dark';
    document.documentElement.setAttribute('data-color', 'accent');
  </script>
  <div id="root" class="aksel-theme dark" data-color="accent"></div>
  
  <script type="module">
    // React will be loaded from Vite via sandboxAksel.ts (same instance as Aksel components)
    let currentRoot = null;
    let akselLoaded = false;
    let ThemeComponent = null;
    let lastComponent = null;

    // Load Aksel + React - detect environment (Vite dev server runs on port 5173)
    const isDev = (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') && window.location.port === '5173';
    
    console.log(`üîß Environment: ${isDev ? 'Development' : 'Production'}`);
    
    // Function to load from production CDN
    async function loadFromCDN() {
      console.log('üì¶ Loading from ESM.sh CDN...');
      
      // Load Darkside CSS via fetch to avoid CORS issues with <link> tags
      try {
        console.log('üì• Fetching Darkside CSS from CDN...');
        const cssResponse = await fetch('https://cdn.nav.no/aksel/@navikt/ds-css/7.33.1/darkside/index.css');
        const cssText = await cssResponse.text();
        const style = document.createElement('style');
        style.textContent = cssText;
        document.head.appendChild(style);
        console.log('‚úÖ Darkside CSS loaded from CDN');
      } catch (err) {
        console.error('‚ùå Failed to load Darkside CSS:', err);
        // Continue anyway - components might still work without styles
      }
      
      // Load React and ReactDOM as UMD (ensures single instance)
      const reactScript = document.createElement('script');
      reactScript.src = 'https://unpkg.com/react@18.3.1/umd/react.production.min.js';
      document.head.appendChild(reactScript);
      await new Promise((resolve, reject) => {
        reactScript.onload = resolve;
        reactScript.onerror = reject;
      });
      
      const reactDomScript = document.createElement('script');
      reactDomScript.src = 'https://unpkg.com/react-dom@18.3.1/umd/react-dom.production.min.js';
      document.head.appendChild(reactDomScript);
      await new Promise((resolve, reject) => {
        reactDomScript.onload = resolve;
        reactDomScript.onerror = reject;
      });
      
      console.log('‚úÖ React loaded from UNPKG (UMD)');
      
      // Now React and ReactDOM are in window.React and window.ReactDOM
      const React = window.React;
      const ReactDOM = window.ReactDOM;
      
      // Load Aksel via ESM.sh but with React as peer dependency
      console.log('üì• Loading Aksel components from ESM.sh...');
      let AkselReact;
      try {
        AkselReact = await import('https://esm.sh/@navikt/ds-react@7.33.1?external=react,react-dom&bundle');
        console.log('‚úÖ AkselReact loaded, keys:', Object.keys(AkselReact).slice(0, 5));
        console.log('üîç AkselReact.Theme:', !!AkselReact.Theme, 'AkselReact.default:', !!AkselReact.default);
      } catch (err) {
        console.error('‚ùå Failed to import AkselReact:', err);
        throw new Error(`AkselReact import failed: ${err.message || err}`);
      }
      
      console.log('üì• Loading Aksel icons from ESM.sh...');
      let AkselIcons;
      try {
        AkselIcons = await import('https://esm.sh/@navikt/aksel-icons@7.33.1?external=react&bundle');
        console.log('‚úÖ AkselIcons loaded, icon count:', Object.keys(AkselIcons).length);
      } catch (err) {
        console.error('‚ùå Failed to import AkselIcons:', err);
        throw new Error(`AkselIcons import failed: ${err.message || err}`);
      }
      
      const components = AkselReact.default || AkselReact;
      const icons = AkselIcons.default || AkselIcons;
      const theme = AkselReact.Theme || AkselReact.default?.Theme;
      
      console.log('üîç Final exports - Components:', typeof components, 'Icons:', typeof icons, 'Theme:', typeof theme);
      
      return {
        React,
        createRoot: ReactDOM.createRoot,
        Theme: theme,
        AkselComponents: components,
        AkselIcons: icons,
      };
    }
    
    // Function to load from Vite dev server
    async function loadFromVite() {
      console.log('üì¶ Loading from Vite dev server...');
      const module = await import('./src/sandboxAksel.ts');
      return module;
    }
    
    // Function to load from built assets (production via local preview or GitHub Pages)
    async function loadFromBuild() {
      console.log('üì¶ Loading from built assets...');
      const basePath = '/aksel-arcade/';
      
      try {
        // Fetch Vite's build manifest to find the sandbox entry point
        const manifest = await fetch(basePath + '.vite/manifest.json').then(r => r.json());
        console.log('üì• Manifest loaded, keys:', Object.keys(manifest));
        
        // Find the sandbox entry in manifest
        const sandboxEntry = manifest['src/sandboxAksel.ts'];
        if (!sandboxEntry || !sandboxEntry.file) {
          throw new Error('Sandbox entry not found in manifest');
        }
        
        // CRITICAL: Use basePath to construct correct absolute path
        // sandbox.html is at /aksel-arcade/sandbox.html
        // assets are at /aksel-arcade/assets/
        // Must use basePath (not '../') to ensure correct path resolution
        const sandboxPath = basePath + sandboxEntry.file;
        console.log('üì• Found sandbox bundle:', sandboxPath);
        
        const module = await import(sandboxPath);
        console.log('‚úÖ Loaded sandbox from built assets');
        console.log('üîç Module keys:', Object.keys(module).slice(0, 10));
        console.log('üîç Module.React:', !!module.React, 'Module.createRoot:', !!module.createRoot);
        console.log('üîç Module.Theme:', !!module.Theme, 'Module.AkselComponents:', !!module.AkselComponents);
        return module;
      } catch (err) {
        console.error('‚ùå Failed to load from built assets:', err);
        // Fallback to CDN
        console.log('üì¶ Falling back to CDN...');
        return loadFromCDN();
      }
    }
    
    // Load based on environment
    console.log('üöÄ Starting module load, isDev:', isDev);
    console.log('üöÄ Will call:', isDev ? 'loadFromVite()' : 'loadFromBuild()');
    
    (isDev ? loadFromVite() : loadFromBuild())
      .then((module) => {
        console.log('‚úÖ Module loaded successfully!');
        console.log('üîç Module keys:', Object.keys(module || {}).slice(0, 15));
        
        // sandboxAksel.ts exports default object with all properties
        // In production, module.default is the sandbox object
        // In dev, Vite unwraps it so module IS the sandbox object
        const sandbox = module.default || module;
        console.log('üîç sandbox.React:', !!sandbox.React, 'sandbox.createRoot:', !!sandbox.createRoot, 'sandbox.Theme:', !!sandbox.Theme);
        
        const { React, createRoot, Theme, AkselComponents, AkselIcons } = sandbox;
        
        // Make React available globally (same instance as Aksel uses)
        window.React = React;
        window.ReactDOM = { createRoot };
        
        // Make React hooks available globally (for user code)
        window.useState = React.useState;
        window.useEffect = React.useEffect;
        window.useContext = React.useContext;
        window.useReducer = React.useReducer;
        window.useCallback = React.useCallback;
        window.useMemo = React.useMemo;
        window.useRef = React.useRef;
        window.useImperativeHandle = React.useImperativeHandle;
        window.useLayoutEffect = React.useLayoutEffect;
        window.useDebugValue = React.useDebugValue;
        
        // Store Theme component
        ThemeComponent = Theme;
        window.Theme = Theme;
        
        // Make all Aksel components available globally
        window.AkselDS = AkselComponents;
        Object.keys(AkselComponents).forEach(key => {
          window[key] = AkselComponents[key];
        });
        
        // Make all Aksel icons available globally
        window.AkselIcons = AkselIcons;
        Object.keys(AkselIcons).forEach(key => {
          window[key] = AkselIcons[key];
        });
        
        akselLoaded = true;
        console.log('‚úÖ Sandbox ready, Aksel + React loaded from Vite:', Object.keys(AkselComponents).length, 'components');
        console.log('‚úÖ Aksel icons loaded:', Object.keys(AkselIcons).length, 'icons');
        console.log('‚úÖ React version:', React.version);
        console.log('‚úÖ Theme component available:', !!ThemeComponent);
        console.log('‚úÖ Darkside CSS imported via @navikt/ds-css/darkside');
        window.parent.postMessage({ type: 'SANDBOX_READY' }, window.location.origin);
      })
      .catch((err) => {
        console.error('‚ùå‚ùå‚ùå CRITICAL ERROR: Module loading failed completely!');
        console.error('‚ùå Error type:', err.name);
        console.error('‚ùå Error message:', err.message);
        console.error('‚ùå Full error:', err);
        console.error('‚ùå Stack:', err.stack);
        console.error('‚ùå Environment was:', isDev ? 'Development' : 'Production');
        
        // Send error to parent so it's visible in main app console
        try {
          window.parent.postMessage({
            type: 'RUNTIME_ERROR',
            payload: {
              message: `Sandbox initialization failed: ${err.message}`,
              componentStack: null,
              stack: err.stack || ''
            }
          }, window.location.origin);
        } catch (postErr) {
          console.error('‚ùå Could not even send error to parent:', postErr);
        }
      });

    // Inspection state (T077)
    let inspectEnabled = false;
    let highlightOverlay = null;
    let lastInspectionTime = 0;
    const INSPECTION_THROTTLE_MS = 16; // ~60fps
    
    // Theme state - matches main app default (dark)
    let currentTheme = 'dark';

    // Listen for messages from parent window
    window.addEventListener('message', (event) => {
      // Security: Validate origin (same-origin only)
      if (event.origin !== window.location.origin) {
        console.warn('‚ùå Rejected message from unauthorized origin:', event.origin)
        return
      }
      
      // Validate message structure
      if (!event.data || typeof event.data !== 'object') return;
      
      const message = event.data;
      console.log('üì• Sandbox received message:', message.type);

      try {
        switch (message.type) {
          case 'EXECUTE_CODE':
            console.log('üöÄ Executing code...');
            executeCode(message.payload);
            break;
          case 'UPDATE_VIEWPORT':
            console.log('üìê Updating viewport...');
            updateViewport(message.payload);
            break;
          case 'TOGGLE_INSPECT':
            console.log('üîç Toggling inspect mode...');
            toggleInspect(message.payload);
            break;
          case 'UPDATE_THEME':
            console.log('üé® Updating theme...');
            updateTheme(message.payload);
            break;
          case 'CHECK_CSS_VARS':
            checkCSSVariables(message.id);
            break;
          default:
            console.warn('Unknown message type:', message.type);
        }
      } catch (error) {
        console.error('‚ùå Message handling error:', error);
        sendError('RUNTIME_ERROR', {
          message: error.message,
          componentStack: null,
          stack: error.stack || ''
        });
      }
    });

    // T077: Handle TOGGLE_INSPECT message
    function toggleInspect(payload) {
      try {
        console.log('üîç toggleInspect called with payload:', payload);
        
        if (!payload || typeof payload.enabled !== 'boolean') {
          console.error('‚ùå Invalid payload for TOGGLE_INSPECT:', payload);
          return;
        }
        
        inspectEnabled = payload.enabled;
        
        if (inspectEnabled) {
          // Attach mousemove listener
          document.addEventListener('mousemove', handleInspectMouseMove);
          console.log('‚úÖ Inspect mode enabled - mousemove listener attached');
        } else {
          // Remove mousemove listener and clear highlight
          document.removeEventListener('mousemove', handleInspectMouseMove);
          clearHighlight();
          sendMessage('INSPECTION_DATA', null);
          console.log('‚úÖ Inspect mode disabled - mousemove listener removed');
        }
      } catch (error) {
        console.error('‚ùå Error in toggleInspect:', error);
        sendError('RUNTIME_ERROR', {
          message: `Inspect toggle error: ${error.message}`,
          componentStack: null,
          stack: error.stack || ''
        });
      }
    }

    // T079: Handle mousemove during inspect mode (throttled to 60fps)
    function handleInspectMouseMove(event) {
      try {
        const now = Date.now();
        if (now - lastInspectionTime < INSPECTION_THROTTLE_MS) return;
        lastInspectionTime = now;

        const element = document.elementFromPoint(event.clientX, event.clientY);
        if (!element || element === document.body || element === document.documentElement) {
          clearHighlight();
          sendMessage('INSPECTION_DATA', null);
          return;
        }

        // T078: Extract inspection data (includes cursor position)
        const inspectionData = extractInspectionData(element, event.clientX, event.clientY);
        
        // Debug: Log inspection data
        console.log('üîç Inspection data:', {
          componentName: inspectionData.componentName,
          color: inspectionData.color,
          fontSize: inspectionData.fontSize,
          hasProps: Object.keys(inspectionData.props || {}).length,
        });
        
        // T081: Display highlight border
        showHighlight(inspectionData.boundingRect);
        
        // T079: Send inspection data to main app
        sendMessage('INSPECTION_DATA', inspectionData);
      } catch (error) {
        console.error('‚ùå Error in handleInspectMouseMove:', error);
        // Don't send error to main app - just log and continue
        // This prevents inspect mode from breaking on edge cases
      }
    }

    // T078: Extract component name, props, and computed styles
    function extractInspectionData(element, cursorX, cursorY) {
      try {
        const computedStyle = window.getComputedStyle(element);
        const rect = element.getBoundingClientRect();
        
        // Try to find React component name from Fiber
        let componentName = element.tagName.toLowerCase();
        try {
          const fiberKey = Object.keys(element).find(key => key.startsWith('__reactFiber'));
          const fiber = fiberKey ? element[fiberKey] : null;
          const componentType = fiber?.type;
          
          if (componentType) {
            if (typeof componentType === 'function') {
              componentName = componentType.name || componentType.displayName || 'Anonymous';
            } else if (typeof componentType === 'string') {
              componentName = componentType;
            }
          }
        } catch (fiberError) {
          console.warn('Could not extract React Fiber info:', fiberError);
          // Continue with tagName as componentName
        }
        
        // Extract React props
        let props = {};
        try {
          const propsKey = Object.keys(element).find(key => key.startsWith('__reactProps'));
          const rawProps = propsKey ? element[propsKey] : {};
          props = sanitizeProps(rawProps);
        } catch (propsError) {
          console.warn('Could not extract React props:', propsError);
          // Continue with empty props
        }
        
        return {
          componentName,
          tagName: element.tagName.toLowerCase(),
          cssClass: element.className || '',
          props,
          color: computedStyle.color,
          fontFamily: computedStyle.fontFamily,
          fontSize: computedStyle.fontSize,
          margin: computedStyle.margin,
          padding: computedStyle.padding,
          boundingRect: {
            x: rect.x,
            y: rect.y,
            width: rect.width,
            height: rect.height,
            top: rect.top,
            right: rect.right,
            bottom: rect.bottom,
            left: rect.left,
          },
          cursorX: cursorX,
          cursorY: cursorY,
        };
      } catch (error) {
        console.error('‚ùå Error in extractInspectionData:', error);
        // Return minimal safe data
        return {
          componentName: 'unknown',
          tagName: element.tagName.toLowerCase(),
          cssClass: '',
          props: {},
          color: '',
          fontFamily: '',
          fontSize: '',
          margin: '',
          padding: '',
          boundingRect: {
            x: 0, y: 0, width: 0, height: 0,
            top: 0, right: 0, bottom: 0, left: 0,
          },
          cursorX: 0,
          cursorY: 0,
        };
      }
    }

    // Remove non-serializable props (functions, circular refs)
    function sanitizeProps(props) {
      const sanitized = {};
      for (const [key, value] of Object.entries(props)) {
        if (typeof value !== 'function' && key !== 'children') {
          try {
            JSON.stringify(value); // Test serializability
            sanitized[key] = value;
          } catch {
            sanitized[key] = '[Non-serializable]';
          }
        }
      }
      return sanitized;
    }

    // T081: Display highlight border around hovered element
    function showHighlight(rect) {
      try {
        if (!highlightOverlay) {
          highlightOverlay = document.createElement('div');
          highlightOverlay.style.position = 'fixed';
          highlightOverlay.style.border = '2px solid #0067C5';
          highlightOverlay.style.backgroundColor = 'rgba(0, 103, 197, 0.1)';
          highlightOverlay.style.pointerEvents = 'none';
          highlightOverlay.style.zIndex = '9998';
          highlightOverlay.style.transition = 'all 0.1s ease';
          document.body.appendChild(highlightOverlay);
        }
        
        highlightOverlay.style.left = `${rect.left}px`;
        highlightOverlay.style.top = `${rect.top}px`;
        highlightOverlay.style.width = `${rect.width}px`;
        highlightOverlay.style.height = `${rect.height}px`;
        highlightOverlay.style.display = 'block';
      } catch (error) {
        console.error('‚ùå Error in showHighlight:', error);
        // Don't propagate error - highlight is non-critical
      }
    }

    function clearHighlight() {
      try {
        if (highlightOverlay) {
          highlightOverlay.style.display = 'none';
        }
      } catch (error) {
        console.error('‚ùå Error in clearHighlight:', error);
        // Don't propagate error
      }
    }

    function checkCSSVariables(messageId) {
      const root = document.getElementById('root');
      const button = document.querySelector('button');
      const rootStyles = root ? getComputedStyle(root) : null;
      const buttonStyles = button ? getComputedStyle(button) : null;
      
      // Get ALL CSS custom properties
      const allCSSVars = [];
      if (rootStyles) {
        for (let i = 0; i < rootStyles.length; i++) {
          const prop = rootStyles[i];
          if (prop.startsWith('--')) {
            allCSSVars.push(prop);
          }
        }
      }
      
      // Check specifically for --ax and --a prefixes
      const axVars = allCSSVars.filter(v => v.startsWith('--ax'));
      const aVars = allCSSVars.filter(v => v.startsWith('--a-') || v.startsWith('--a_'));
      
      // Get button attributes
      const buttonAttrs = {};
      if (button) {
        for (let attr of button.attributes) {
          buttonAttrs[attr.name] = attr.value;
        }
      }
      
      const result = {
        id: messageId,
        result: {
          rootClasses: root?.className,
          buttonClasses: button?.className,
          buttonAttributes: buttonAttrs,
          buttonExists: !!button,
          buttonBg: buttonStyles?.backgroundColor,
          buttonPadding: buttonStyles?.padding,
          buttonFontSize: buttonStyles?.fontSize,
          buttonFontFamily: buttonStyles?.fontFamily,
          totalCSSVars: allCSSVars.length,
          axVarCount: axVars.length,
          aVarCount: aVars.length,
          axVarSample: axVars.slice(0, 5),
          aVarSample: aVars.slice(0, 5),
          darksideCSSLoaded: !!document.querySelector('link[href*="darkside"]'),
          allStylesheets: Array.from(document.styleSheets).map(s => s.href).filter(Boolean)
        }
      };
      
      window.parent.postMessage(result, window.location.origin);
    }

    function updateViewport(payload) {
      const { width } = payload;
      const rootElement = document.getElementById('root');
      
      if (!rootElement) return;
      
      console.log(`üìê Setting viewport width to ${width}px`);
      
      // Update the root element width with smooth transition
      rootElement.style.maxWidth = `${width}px`;
      rootElement.style.margin = '0 auto';
      rootElement.style.transition = 'max-width 0.3s ease';
    }

    function updateTheme(payload) {
      try {
        const { theme } = payload;
        
        if (!theme || (theme !== 'light' && theme !== 'dark')) {
          console.error('‚ùå Invalid theme:', theme);
          return;
        }
        
        console.log(`üé® Updating theme to ${theme}`);
        currentTheme = theme;
        
        // Update html element classes and color-scheme for background
        document.documentElement.className = `aksel-theme ${theme}`;
        document.documentElement.setAttribute('data-color', 'accent');
        document.documentElement.style.colorScheme = theme;
        
        // Update root element classes and color-scheme
        const rootElement = document.getElementById('root');
        if (rootElement) {
          rootElement.className = `aksel-theme ${theme}`;
          rootElement.style.colorScheme = theme;
        }
        
        // Re-render current component with new theme if exists
        if (currentRoot && lastComponent) {
          console.log('üîÑ Re-rendering with new theme...');
          renderComponent(lastComponent);
          sendMessage('THEME_UPDATED', { theme });
        }
      } catch (error) {
        console.error('‚ùå Error in updateTheme:', error);
        sendError('RUNTIME_ERROR', {
          message: `Theme update error: ${error.message}`,
          componentStack: null,
          stack: error.stack || ''
        });
      }
    }

    function executeCode(payload) {
      try {
        const { jsxCode } = payload;
        
        console.log('üìÑ Code length:', jsxCode?.length || 0);
        
        if (!jsxCode) {
          console.log('‚è∏Ô∏è No code to execute, clearing root');
          clearRoot();
          return;
        }

        // Check if Aksel is loaded
        if (!akselLoaded) {
          console.warn('‚è∏Ô∏è Aksel not loaded yet, queuing code execution');
          setTimeout(() => executeCode(payload), 100);
          return;
        }

        console.log('üé® Executing code with all Aksel components and icons from window');

        // Execute the transpiled code with all Aksel components and icons in scope
        console.log('üîß Evaluating transpiled code...');
        
        // Build component declarations safely
        const componentDeclarations = window.AkselDS 
          ? Object.keys(window.AkselDS)
              .filter(key => typeof window[key] !== 'undefined') // Only include defined components
              .map(key => `const ${key} = window.${key};`)
              .join('\n')
          : '';
        
        // Build icon declarations safely
        const iconDeclarations = window.AkselIcons
          ? Object.keys(window.AkselIcons)
              .filter(key => typeof window[key] !== 'undefined') // Only include defined icons
              .map(key => `const ${key} = window.${key};`)
              .join('\n')
          : '';
        
        // Debug: Check if Button and PencilIcon are available
        console.log('üîç DEBUG: window.Button type:', typeof window.Button);
        console.log('üîç DEBUG: window.PencilIcon type:', typeof window.PencilIcon);
        console.log('üîç DEBUG: Component declarations count:', componentDeclarations.split('\n').length);
        console.log('üîç DEBUG: Icon declarations count:', iconDeclarations.split('\n').length);
        
        const wrappedCode = `
          (function() {
            // Make all Aksel components available
            ${componentDeclarations}
            
            // Make all Aksel icons available
            ${iconDeclarations}
            
            // Make React hooks available
            const { useState, useEffect, useContext, useReducer, useCallback, useMemo, useRef } = window.React;
            
            // Debug log inside eval scope
            console.log('üîç Inside eval - Button type:', typeof Button);
            console.log('üîç Inside eval - Button is:', Button);
            
            ${jsxCode}
            
            // Try to find the component
            if (typeof App !== 'undefined') return App;
            if (typeof exports !== 'undefined' && exports.default) return exports.default;
            throw new Error('No component found. Please export default function App() { ... }');
          })()
        `;
        
        const Component = eval(wrappedCode);
        console.log('‚úÖ Component evaluated:', typeof Component);

        if (!Component || typeof Component !== 'function') {
          throw new Error('Invalid component. Make sure to export a React component.');
        }

        // Store component for re-rendering on theme change
        lastComponent = Component;
        
        // Render the component
        console.log('üé® Rendering component...');
        renderComponent(Component);

        // Send success message
        sendMessage('RENDER_SUCCESS', {});
        console.log('‚úÖ Render success');
      } catch (error) {
        console.error('‚ùå Execution error:', error);
        sendError('RUNTIME_ERROR', {
          message: error.message,
          componentStack: extractComponentStack(error),
          stack: error.stack || ''
        });
      }
    }

    function renderComponent(Component) {
      const rootElement = document.getElementById('root');
      
      if (!rootElement) {
        throw new Error('Root element not found');
      }

      try {
        // Clear previous root if it exists
        if (currentRoot) {
          currentRoot.unmount();
        }

        // Create new root and render
        currentRoot = ReactDOM.createRoot(rootElement);
        
        // CRITICAL: Wrap component with Theme for Aksel Darkside to work
        // Per Aksel docs: "m√• du bruke den nye Theme-komponenten"
        if (!ThemeComponent) {
          throw new Error('Theme component not loaded. Make sure Vite dev server is running.');
        }
        
        console.log(`üé® Rendering component wrapped with Aksel Theme (${currentTheme} mode)`);
        
        // CRITICAL FIX: Ensure theme is explicitly 'light' or 'dark', never undefined
        const themeValue = currentTheme === 'dark' ? 'dark' : 'light';
        console.log(`üîç DEBUG: currentTheme variable = "${currentTheme}"`);
        console.log(`üîç DEBUG: Theme value being passed to Theme component: "${themeValue}"`);
        console.log(`üîç DEBUG: Theme component props:`, { theme: themeValue });
        
        const wrappedComponent = React.createElement(
          ThemeComponent,
          { theme: themeValue },
          React.createElement(Component)
        );
        
        console.log(`üîç DEBUG: Created Theme element:`, wrappedComponent);
        
        currentRoot.render(wrappedComponent);
        
        // Debug: Check rendered elements and theme after a short delay
        setTimeout(() => {
          // Check theme wrapper
          const themeWrapper = rootElement.querySelector('.aksel-theme');
          if (themeWrapper) {
            console.log('üîç DEBUG: Theme wrapper classes:', themeWrapper.className);
            console.log('üîç DEBUG: Theme wrapper color-scheme:', getComputedStyle(themeWrapper).colorScheme);
          }
          
          // Check Alert component
          const alert = rootElement.querySelector('[class*="aksel-alert"]');
          if (alert) {
            console.log('üîç DEBUG: Alert classes:', alert.className);
            console.log('üîç DEBUG: Alert computed color:', getComputedStyle(alert).color);
            console.log('üîç DEBUG: Alert computed background:', getComputedStyle(alert).backgroundColor);
            console.log('üîç DEBUG: Alert color-scheme:', getComputedStyle(alert).colorScheme);
          }
          
          // Check any button
          const button = rootElement.querySelector('button');
          if (button) {
            console.log('üîç DEBUG: Button classes:', button.className);
            console.log('üîç DEBUG: Button computed color:', getComputedStyle(button).color);
          }
        }, 100);
      } catch (error) {
        sendError('RUNTIME_ERROR', {
          message: error.message,
          componentStack: extractComponentStack(error),
          stack: error.stack || ''
        });
        throw error;
      }
    }

    function clearRoot() {
      if (currentRoot) {
        currentRoot.unmount();
        currentRoot = null;
      }
      lastComponent = null;
      const rootElement = document.getElementById('root');
      if (rootElement) {
        rootElement.innerHTML = '';
      }
    }

    function sendMessage(type, payload) {
      window.parent.postMessage({ type, payload }, window.location.origin);
    }

    function sendError(type, payload) {
      window.parent.postMessage({ type, payload }, window.location.origin);
    }

    function extractLineNumber(error) {
      const match = error.stack?.match(/:(\d+):\d+/);
      return match ? parseInt(match[1], 10) - 1 : null; // 0-indexed
    }

    function extractComponentStack(error) {
      // Try to extract React component stack if available
      if (error.componentStack) {
        return error.componentStack;
      }
      return null;
    }

    // Proxy console methods to send to parent
    const originalConsole = {
      log: console.log,
      warn: console.warn,
      error: console.error,
      info: console.info
    };

    ['log', 'warn', 'error', 'info'].forEach(level => {
      console[level] = (...args) => {
        originalConsole[level](...args);
        sendMessage('CONSOLE_LOG', {
          level,
          args: args.map(arg => {
            try {
              return typeof arg === 'object' ? JSON.stringify(arg) : String(arg);
            } catch {
              return String(arg);
            }
          })
        });
      };
    });
  </script>
</body>
</html>
